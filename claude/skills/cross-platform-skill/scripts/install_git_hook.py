#!/usr/bin/env python3
"""
Install a git pre-commit hook that keeps instruction files in sync.

Usage:
    python install_git_hook.py [--canonical <file>] [--uninstall]
    
Examples:
    # Install hook using CLAUDE.md as canonical
    python install_git_hook.py
    
    # Install hook using AGENTS.md as canonical
    python install_git_hook.py --canonical AGENTS.md
    
    # Uninstall the hook
    python install_git_hook.py --uninstall
"""

import argparse
import os
import stat
import subprocess
import sys
from pathlib import Path


HOOK_MARKER = "# cross-platform-skill-sync"

HOOK_TEMPLATE = '''#!/bin/bash
{marker}
# Auto-generated by cross-platform-skill
# Keeps instruction files in sync across platforms

CANONICAL="{canonical}"

if [ -f "$CANONICAL" ]; then
    # Get list of target files
    case "$CANONICAL" in
        CLAUDE.md)
            TARGETS="AGENTS.md GEMINI.md"
            ;;
        AGENTS.md)
            TARGETS="CLAUDE.md GEMINI.md"
            ;;
        GEMINI.md)
            TARGETS="CLAUDE.md AGENTS.md"
            ;;
        *)
            TARGETS="CLAUDE.md AGENTS.md GEMINI.md"
            ;;
    esac
    
    # Copy canonical to targets
    for target in $TARGETS; do
        if [ "$target" != "$CANONICAL" ]; then
            # Add header comment and copy
            echo "<!-- Synced from $CANONICAL - Do not edit directly -->" > "$target"
            cat "$CANONICAL" >> "$target"
            git add "$target"
        fi
    done
    
    echo "Synced instruction files from $CANONICAL"
fi
'''


def find_git_root() -> Path:
    """Find the root of the git repository."""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--show-toplevel'],
            capture_output=True,
            text=True,
            check=True
        )
        return Path(result.stdout.strip())
    except subprocess.CalledProcessError:
        print("Error: Not in a git repository", file=sys.stderr)
        sys.exit(1)


def get_hook_path(git_root: Path) -> Path:
    """Get the path to the pre-commit hook."""
    return git_root / '.git' / 'hooks' / 'pre-commit'


def read_existing_hook(hook_path: Path) -> str:
    """Read existing hook content if present."""
    if hook_path.exists():
        return hook_path.read_text()
    return ""


def install_hook(canonical: str, git_root: Path) -> None:
    """Install or update the pre-commit hook."""
    hook_path = get_hook_path(git_root)
    existing = read_existing_hook(hook_path)
    
    new_hook = HOOK_TEMPLATE.format(marker=HOOK_MARKER, canonical=canonical)
    
    if existing:
        if HOOK_MARKER in existing:
            # Update existing cross-platform section
            lines = existing.split('\n')
            new_lines = []
            skip_until_next_section = False
            
            for line in lines:
                if HOOK_MARKER in line:
                    skip_until_next_section = True
                    continue
                elif skip_until_next_section:
                    # Skip until we find next hook section or end
                    if line.startswith('#') and 'cross-platform' not in line.lower():
                        skip_until_next_section = False
                        new_lines.append(line)
                    elif not line.strip() and new_lines and not new_lines[-1].strip():
                        continue  # Skip double blank lines
                else:
                    new_lines.append(line)
            
            # Append our hook
            final_content = '\n'.join(new_lines).rstrip() + '\n\n' + new_hook
            print(f"Updating existing pre-commit hook: {hook_path}")
        else:
            # Append to existing hook
            final_content = existing.rstrip() + '\n\n' + new_hook
            print(f"Appending to existing pre-commit hook: {hook_path}")
    else:
        # Create new hook
        final_content = '#!/bin/bash\n\n' + new_hook
        print(f"Creating new pre-commit hook: {hook_path}")
    
    # Write hook
    hook_path.parent.mkdir(parents=True, exist_ok=True)
    hook_path.write_text(final_content)
    
    # Make executable
    hook_path.chmod(hook_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    
    print(f"Hook installed successfully!")
    print(f"Canonical file: {canonical}")
    print()
    print("The hook will automatically sync instruction files on each commit.")


def uninstall_hook(git_root: Path) -> None:
    """Remove the cross-platform sync section from the hook."""
    hook_path = get_hook_path(git_root)
    
    if not hook_path.exists():
        print("No pre-commit hook found.")
        return
    
    existing = hook_path.read_text()
    
    if HOOK_MARKER not in existing:
        print("Cross-platform sync hook not found in pre-commit hook.")
        return
    
    # Remove our section
    lines = existing.split('\n')
    new_lines = []
    skip_until_next_section = False
    
    for line in lines:
        if HOOK_MARKER in line:
            skip_until_next_section = True
            continue
        elif skip_until_next_section:
            if line.startswith('#') and 'cross-platform' not in line.lower():
                skip_until_next_section = False
                new_lines.append(line)
        else:
            new_lines.append(line)
    
    # Clean up multiple blank lines
    final_lines = []
    prev_blank = False
    for line in new_lines:
        is_blank = not line.strip()
        if is_blank and prev_blank:
            continue
        final_lines.append(line)
        prev_blank = is_blank
    
    final_content = '\n'.join(final_lines).strip()
    
    if final_content == '#!/bin/bash' or not final_content:
        # Hook is now empty, remove it
        hook_path.unlink()
        print(f"Removed empty pre-commit hook: {hook_path}")
    else:
        hook_path.write_text(final_content + '\n')
        print(f"Removed cross-platform sync from pre-commit hook: {hook_path}")


def main():
    parser = argparse.ArgumentParser(
        description='Install git hook to sync instruction files'
    )
    parser.add_argument(
        '--canonical', '-c',
        default='CLAUDE.md',
        help='Canonical instruction file (default: CLAUDE.md)'
    )
    parser.add_argument(
        '--uninstall', '-u',
        action='store_true',
        help='Remove the sync hook'
    )
    
    args = parser.parse_args()
    
    git_root = find_git_root()
    
    if args.uninstall:
        uninstall_hook(git_root)
    else:
        install_hook(args.canonical, git_root)


if __name__ == '__main__':
    main()
